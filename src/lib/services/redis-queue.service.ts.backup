import { RedisService } from './redis.service';
import { NotificationExecutorService } from './notification-executor.service';

/**
 * Redis Queue Worker –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –∏ —Ñ–æ–Ω–æ–≤—ã—Ö –∑–∞–¥–∞—á
 * –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–û –¥–ª—è Upstash Redis (short-lived —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è)
 */
export class RedisQueueService {
  private static isRunning = false;
  private static pollingInterval = 10000; // 10 —Å–µ–∫—É–Ω–¥ (—É–≤–µ–ª–∏—á–∏–ª–∏ –¥–ª—è serverless)
  private static queueName = 'notifications';
  private static processTimeout: NodeJS.Timeout | null = null;

  /**
   * –ó–∞–ø—É—Å–∫ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –æ—á–µ—Ä–µ–¥–∏ (short-lived)
   */
  static async startWorker(): Promise<void> {
    if (this.isRunning) {
      console.log('‚ö†Ô∏è Queue worker already running');
      return;
    }

    if (!RedisService.isAvailable()) {
      console.log('‚ö†Ô∏è Redis not available, queue worker disabled');
      return;
    }

    this.isRunning = true;
    console.log('üöÄ Starting Redis Queue Worker (Upstash optimized)');

    // –ó–∞–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–≤—É—é –∏—Ç–µ—Ä–∞—Ü–∏—é
    await this.processSingleIteration();
    
    // –ü–ª–∞–Ω–∏—Ä—É–µ–º —Å–ª–µ–¥—É—é—â—É—é –∏—Ç–µ—Ä–∞—Ü–∏—é
    this.scheduleNextIteration();
  }

  /**
   * –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –æ—á–µ—Ä–µ–¥–∏
   */
  static stopWorker(): void {
    this.isRunning = false;
    
    if (this.processTimeout) {
      clearTimeout(this.processTimeout);
      this.processTimeout = null;
    }
    
    console.log('‚èπÔ∏è Stopping Redis Queue Worker');
  }

  /**
   * –ü–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–ª–µ–¥—É—é—â–µ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏
   */
  private static scheduleNextIteration(): void {
    if (!this.isRunning) return;
    
    this.processTimeout = setTimeout(async () => {
      if (this.isRunning) {
        await this.processSingleIteration();
        this.scheduleNextIteration();
      }
    }, this.pollingInterval);
  }

  /**
   * –û–¥–Ω–∞ –∏—Ç–µ—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ (short-lived)
   */
  private static async processSingleIteration(): Promise<void> {
    try {
      console.log('üîÑ Processing queues iteration...');
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å Redis –ø–µ—Ä–µ–¥ –∫–∞–∂–¥–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–µ–π
      if (!RedisService.isAvailable()) {
        console.log('‚ö†Ô∏è Redis unavailable, skipping iteration');
        return;
      }

      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è (–∫–æ—Ä–æ—Ç–∫–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ)
      await this.processNotificationQueue();
      
      // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∞–Ω–∞–ª–∏—Ç–∏–∫—É (–∫–æ—Ä–æ—Ç–∫–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ)
      await this.processAnalyticsQueue();
      
      console.log('‚úÖ Queue iteration completed');
      
    } catch (error) {
      console.error('‚ùå Queue processing error:', error);
    }
  }

  /**
   * –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—á–µ—Ä–µ–¥–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π (short-lived)
   */
  private static async processNotificationQueue(): Promise<void> {
    let client = null;
    
    try {
      // –û—Ç–∫—Ä—ã–≤–∞–µ–º –∫–æ—Ä–æ—Ç–∫–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ
      client = RedisService.getClient();
      if (!client) return;

      // –ü–æ–ª—É—á–∞–µ–º –∑–∞–¥–∞—á–∏ –∏–∑ –æ—á–µ—Ä–µ–¥–∏
      const jobs = await this.getNotificationJobs(5); // –ú–µ–Ω—å—à–µ –∑–∞–¥–∞—á –∑–∞ —Ä–∞–∑
      
      if (jobs.length === 0) {
        console.log('üì≠ No notification jobs in queue');
        return;
      }

      console.log(`üì® Processing ${jobs.length} notification jobs`);
      
      for (const job of jobs) {
        try {
          console.log(`üì® Processing notification job: ${job.id}`);
          
          // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
          await this.handleNotificationJob(job);
          
          // –£–¥–∞–ª—è–µ–º –∑–∞–¥–∞—á—É –∏–∑ –æ—á–µ—Ä–µ–¥–∏
          await this.removeNotificationJob(job.id);
          
          console.log(`‚úÖ Notification job ${job.id} completed`);
          
        } catch (error) {
          console.error(`‚ùå Failed to process notification job ${job.id}:`, error);
          
          // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –ø–æ–ø—ã—Ç–æ–∫
          job.retryCount = (job.retryCount || 0) + 1;
          
          // –ï—Å–ª–∏ –ø—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –ø–æ–ø—ã—Ç–æ–∫, —É–¥–∞–ª—è–µ–º –∑–∞–¥–∞—á—É
          if (job.retryCount >= 3) {
            await this.removeNotificationJob(job.id);
            console.log(`‚ùå Notification job ${job.id} failed after 3 attempts`);
          } else {
            // –ü–µ—Ä–µ–ø–ª–∞–Ω–∏—Ä—É–µ–º —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π
            await this.rescheduleJob(job);
            console.log(`üîÑ Notification job ${job.id} rescheduled, attempt ${job.retryCount}`);
          }
        }
      }
      
    } catch (error) {
      console.error('‚ùå Error processing notification queue:', error);
    }
    // –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–∫—Ä–æ–µ—Ç—Å—è (short-lived)
  }

  /**
   * –ü–æ–ª—É—á–µ–Ω–∏–µ –∑–∞–¥–∞—á —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π (–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–æ –¥–ª—è Upstash)
   */
  private static async getNotificationJobs(limit: number = 5): Promise<any[]> {
    try {
      const client = RedisService.getClient();
      if (!client) return [];

      // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—Å–ø–æ–ª—å–∑—É–µ–º LPOP –¥–ª—è –∞—Ç–æ–º–∞—Ä–Ω–æ–≥–æ –ø–æ–ª—É—á–µ–Ω–∏—è –∏ —É–¥–∞–ª–µ–Ω–∏—è –∑–∞–¥–∞—á
      // –≠—Ç–æ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á –º–µ–∂–¥—É worker'–∞–º–∏
      const jobs: any[] = [];
      
      for (let i = 0; i < limit; i++) {
        const jobStr = await client.lpop(this.queueName);
        if (!jobStr) break; // –û—á–µ—Ä–µ–¥—å –ø—É—Å—Ç–∞
        
        try {
          const job = JSON.parse(jobStr);
          jobs.push({
            id: `job_${Date.now()}_${i}`,
            data: job,
            retryCount: job.retryCount || 0
          });
        } catch (parseError) {
          console.error('‚ùå Failed to parse job:', parseError);
          // –ó–∞–¥–∞—á–∞ —É–∂–µ —É–¥–∞–ª–µ–Ω–∞ –∏–∑ –æ—á–µ—Ä–µ–¥–∏, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º
        }
      }
      
      return jobs;
      
    } catch (error) {
      console.error('‚ùå Error getting notification jobs:', error);
      return [];
    }
  }

  /**
   * –£–¥–∞–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
   */
  private static async removeNotificationJob(jobId: string): Promise<void> {
    try {
      const client = RedisService.getClient();
      if (!client) return;

      // –£–¥–∞–ª—è–µ–º –ø–µ—Ä–≤—ã–π —ç–ª–µ–º–µ–Ω—Ç –∏–∑ —Å–ø–∏—Å–∫–∞ (FIFO)
      await client.lpop(this.queueName);
      
    } catch (error) {
      console.error('‚ùå Error removing notification job:', error);
    }
  }

  /**
   * –ü–µ—Ä–µ–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏
   */
  private static async rescheduleJob(job: any): Promise<void> {
    try {
      const client = RedisService.getClient();
      if (!client) return;

      // –£–¥–∞–ª—è–µ–º —Ç–µ–∫—É—â—É—é –∑–∞–¥–∞—á—É
      await client.lpop(this.queueName);
      
      // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞—Ç–Ω–æ –≤ –∫–æ–Ω–µ—Ü –æ—á–µ—Ä–µ–¥–∏ —Å —É–≤–µ–ª–∏—á–µ–Ω–Ω—ã–º —Å—á–µ—Ç—á–∏–∫–æ–º
      const rescheduledJob = {
        ...job.data,
        retryCount: job.retryCount
      };
      
      await client.rpush(this.queueName, JSON.stringify(rescheduledJob));
      
    } catch (error) {
      console.error('‚ùå Error rescheduling job:', error);
    }
  }

  /**
   * –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–¥–∞—á–∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
   */
  private static async handleNotificationJob(job: any): Promise<void> {
    const { type, data } = job.data;
    
    switch (type) {
      case 'payment_reminder':
        await this.handlePaymentReminder(data);
        break;
        
      case 'bonus_notification':
        await this.handleBonusNotification(data);
        break;
        
      case 'restock_notification':
        await this.handleRestockNotification(data);
        break;
        
      case 'order_status_update':
        await this.handleOrderStatusUpdate(data);
        break;
        
      case 'order_status_change':
        await this.handleOrderStatusChange(data);
        break;
        
      default:
        console.warn(`‚ö†Ô∏è Unknown notification type: ${type}`);
    }
  }

  /**
   * –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –æ–± –æ–ø–ª–∞—Ç–µ
   */
  private static async handlePaymentReminder(data: any): Promise<void> {
    const { orderId, reminderType } = data;
    
    const jobData = {
      order_id: orderId,
      reminder_type: reminderType
    };
    
    await NotificationExecutorService.executePaymentReminder(Date.now(), jobData);
  }

  /**
   * –û–±—Ä–∞–±–æ—Ç–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –±–æ–Ω—É—Å–∞—Ö
   */
  private static async handleBonusNotification(data: any): Promise<void> {
    const { orderId, bonusAmount } = data;
    
    const jobData = {
      order_id: orderId,
      bonus_amount: bonusAmount
    };
    
    await NotificationExecutorService.executeBonusNotification(Date.now(), jobData);
  }

  /**
   * –û–±—Ä–∞–±–æ—Ç–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –ø–æ—Å—Ç—É–ø–ª–µ–Ω–∏–∏ —Ç–æ–≤–∞—Ä–∞
   */
  private static async handleRestockNotification(data: any): Promise<void> {
    const { productId, userId } = data;
    
    const jobData = {
      product_id: productId,
      user_id: userId
    };
    
    await NotificationExecutorService.executeRestockNotification(Date.now(), jobData);
  }

  /**
   * –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–∫–∞–∑–∞
   */
  private static async handleOrderStatusUpdate(data: any): Promise<void> {
    const { orderId, status, userId } = data;
    
    // –ò–Ω–∫—Ä–µ–º–µ–Ω—Ç–∏—Ä—É–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (short connection)
    if (userId) {
      try {
        const client = RedisService.getClient();
        if (client) {
          const key = `activity:${new Date().toISOString().split('T')[0]}:${userId}`