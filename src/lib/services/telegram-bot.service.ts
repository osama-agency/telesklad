interface TelegramMessage {
  chat_id: number | string;
  text: string;
  parse_mode?: 'HTML' | 'Markdown';
  reply_markup?: {
    inline_keyboard: InlineKeyboardButton[][];
  };
}

interface InlineKeyboardButton {
  text: string;
  callback_data?: string;
  web_app?: {
    url: string;
  };
  url?: string;
}

interface Purchase {
  id: number;
  totalAmount: number;
  status: string;
  isUrgent?: boolean;
  items: {
    productName: string;
    quantity: number;
    costPrice: number;
    total: number;
  }[];
  createdAt: string;
  supplierName?: string;
  notes?: string;
}

export class TelegramBotService {
  private static readonly BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
  private static readonly API_URL = `https://api.telegram.org/bot${TelegramBotService.BOT_TOKEN}`;
  
  // –ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ ID –∏–∑ –≤–∞—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö
  private static readonly GROUP_CHAT_ID = process.env.TELEGRAM_GROUP_CHAT_ID || '-4729817036';
  private static readonly SUPPLIER_ID = process.env.TELEGRAM_SUPPLIER_ID || '7828956680';
  private static readonly ADMIN_ID = process.env.TELEGRAM_ADMIN_ID || '125861752';

  /**
   * –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ Telegram
   */
  private static async sendMessage(message: TelegramMessage): Promise<any> {
    if (!this.BOT_TOKEN) {
      console.error('‚ùå TELEGRAM_BOT_TOKEN not configured');
      return null;
    }

    // –í —Ä–µ–∂–∏–º–µ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∑–∞–≥–ª—É—à–∫—É —Ç–æ–ª—å–∫–æ –¥–ª—è –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞, –Ω–æ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∞–ª—å–Ω–æ –≤ –≥—Ä—É–ø–ø—É
    if (process.env.NODE_ENV === 'development' && message.chat_id !== this.GROUP_CHAT_ID) {
      console.log(`üîß DEV MODE: Simulating Telegram message to ${message.chat_id}`);
      console.log(`üìù Message: ${message.text.substring(0, 200)}...`);
      return {
        ok: true,
        result: {
          message_id: Math.floor(Math.random() * 10000),
          chat: { id: message.chat_id },
          date: Math.floor(Date.now() / 1000),
          text: message.text
        }
      };
    }

    try {
      console.log(`üì§ Sending message to ${message.chat_id}:`, message.text.substring(0, 100) + '...');
      
      const response = await fetch(`${this.API_URL}/sendMessage`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(message),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Telegram API error: ${response.status} ${response.statusText} - ${errorText}`);
      }

      const result = await response.json();
      console.log('‚úÖ Message sent successfully, message_id:', result.result?.message_id);
      return result;
    } catch (error) {
      console.error('‚ùå Error sending Telegram message:', error);
      return null;
    }
  }

  /**
   * –û–±–Ω–æ–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ Telegram
   */
  private static async editMessage(chatId: number | string, messageId: number, text: string, replyMarkup?: any): Promise<any> {
    if (!this.BOT_TOKEN) {
      console.error('‚ùå TELEGRAM_BOT_TOKEN not configured');
      return null;
    }

    try {
      console.log(`üìù Editing message ${messageId} in chat ${chatId}`);
      
      const response = await fetch(`${this.API_URL}/editMessageText`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          chat_id: chatId,
          message_id: messageId,
          text,
          parse_mode: 'HTML',
          reply_markup: replyMarkup,
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Telegram API error: ${response.status} ${response.statusText} - ${errorText}`);
      }

      const result = await response.json();
      console.log('‚úÖ Message edited successfully');
      return result;
    } catch (error) {
      console.error('‚ùå Error editing Telegram message:', error);
      return null;
    }
  }

  /**
   * –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞—Ç—å –∑–∞–∫—É–ø–∫—É –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
   */
  private static formatPurchase(purchase: Purchase, showEditButton: boolean = false): string {
    const items = purchase.items
      .map(item => `‚Ä¢ ${item.productName} - ${item.quantity} —à—Ç. √ó ${item.costPrice} ‚Ç∫ = ${item.total} ‚Ç∫`)
      .join('\n');

    const urgentTag = purchase.isUrgent ? 'üî¥ –°–†–û–ß–ù–û! ' : '';
    const status = this.getStatusText(purchase.status);

    let text = `${urgentTag}<b>–ó–∞–∫—É–ø–∫–∞ #${purchase.id}</b>
<b>–°—Ç–∞—Ç—É—Å:</b> ${status}

<b>–¢–æ–≤–∞—Ä—ã:</b>
${items}

<b>–û–±—â–∞—è —Å—É–º–º–∞:</b> ${purchase.totalAmount} ‚Ç∫
<b>–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è:</b> ${new Date(purchase.createdAt).toLocaleString('ru-RU')}`;

    if (purchase.supplierName) {
      text += `\n<b>–ü–æ—Å—Ç–∞–≤—â–∏–∫:</b> ${purchase.supplierName}`;
    }

    if (purchase.notes) {
      text += `\n<b>–ü—Ä–∏–º–µ—á–∞–Ω–∏—è:</b> ${purchase.notes}`;
    }

    return text;
  }

  /**
   * –ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—Å—Ç —Å—Ç–∞—Ç—É—Å–∞
   */
  private static getStatusText(status: string): string {
    switch (status) {
      case 'draft': return 'üóíÔ∏è –ß–µ—Ä–Ω–æ–≤–∏–∫';
      case 'sent_to_supplier': return 'üì§ –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –ø–æ—Å—Ç–∞–≤—â–∏–∫—É';
      case 'supplier_editing': return '‚úèÔ∏è –ü–æ—Å—Ç–∞–≤—â–∏–∫ —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ—Ç';
      case 'awaiting_payment': return 'üí≥ –û–∂–∏–¥–∞–µ—Ç –æ–ø–ª–∞—Ç—É';
      case 'paid': return 'üí∞ –û–ø–ª–∞—á–µ–Ω–æ';
      case 'preparing': return 'üì¶ –ì–æ—Ç–æ–≤–∏—Ç—Å—è –∫ –æ—Ç–ø—Ä–∞–≤–∫–µ';
      case 'shipped': return 'üöö –û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ –∫–∞—Ä–≥–æ';
      case 'in_transit': return 'üõ´ –í –ø—É—Ç–∏';
      case 'delivered': return '‚úÖ –î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ';
      case 'cancelled': return '‚ùå –û—Ç–º–µ–Ω–µ–Ω–æ';
      default: return status;
    }
  }

  /**
   * 1. –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–≤—É—é –∑–∞–∫—É–ø–∫—É –ø–æ—Å—Ç–∞–≤—â–∏–∫—É
   */
  static async sendPurchaseToSupplier(purchase: Purchase): Promise<{ success: boolean; messageId?: number }> {
    console.log(`üöÄ Sending purchase #${purchase.id} to supplier ${this.SUPPLIER_ID}`);

    const webAppUrl = `${process.env.NEXTAUTH_URL || 'http://localhost:3000'}/telegram-webapp/purchase-editor.html?purchaseId=${purchase.id}`;

    const message: TelegramMessage = {
      chat_id: this.SUPPLIER_ID,
      text: `üìã <b>–ù–æ–≤–∞—è –∑–∞–∫—É–ø–∫–∞ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏</b>

${this.formatPurchase({ ...purchase, status: 'sent_to_supplier' })}

<i>–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ —Ç–æ–≤–∞—Ä—ã, –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä—É–π—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏ —Ü–µ–Ω—ã –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏, –∑–∞—Ç–µ–º –Ω–∞–∂–º–∏—Ç–µ "–ì–æ—Ç–æ–≤–æ –∫ –æ–ø–ª–∞—Ç–µ"</i>`,
      parse_mode: 'HTML',
      reply_markup: {
        inline_keyboard: [
          [
            {
              text: 'üìù –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –∑–∞–∫—É–ø–∫—É',
              web_app: {
                url: webAppUrl
              }
            }
          ],
          [
            {
              text: 'üí∞ –ì–æ—Ç–æ–≤–æ –∫ –æ–ø–ª–∞—Ç–µ',
              callback_data: `purchase_ready_${purchase.id}`
            }
          ]
        ]
      }
    };

    const result = await this.sendMessage(message);
    
    if (result && result.ok) {
      console.log(`‚úÖ Purchase sent to supplier, message_id: ${result.result.message_id}`);
      return { success: true, messageId: result.result.message_id };
    }
    
    console.log('‚ùå Failed to send purchase to supplier');
    return { success: false };
  }

  /**
   * 2. –£–≤–µ–¥–æ–º–∏—Ç—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –æ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –∫ –æ–ø–ª–∞—Ç–µ
   */
  static async notifyAdminPaymentReady(purchase: Purchase): Promise<{ success: boolean; messageId?: number }> {
    console.log(`üí∞ Notifying admin about payment ready for purchase #${purchase.id}`);

    const message: TelegramMessage = {
      chat_id: this.ADMIN_ID,
      text: `üí∞ <b>–ó–∞–∫—É–ø–∫–∞ –≥–æ—Ç–æ–≤–∞ –∫ –æ–ø–ª–∞—Ç–µ!</b>

${this.formatPurchase({ ...purchase, status: 'awaiting_payment' })}

<i>–ü–æ—Å—Ç–∞–≤—â–∏–∫ –ø–æ–¥–≥–æ—Ç–æ–≤–∏–ª –∑–∞–∫—É–ø–∫—É. –ù–µ–æ–±—Ö–æ–¥–∏–º–æ –ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ –æ–ø–ª–∞—Ç—É.</i>`,
      parse_mode: 'HTML',
      reply_markup: {
        inline_keyboard: [
          [
            {
              text: '‚úÖ –û–ø–ª–∞—á–µ–Ω–æ',
              callback_data: `purchase_paid_${purchase.id}`
            },
            {
              text: '‚ùå –û—Ç–º–µ–Ω–∏—Ç—å',
              callback_data: `purchase_cancel_${purchase.id}`
            }
          ]
        ]
      }
    };

    const result = await this.sendMessage(message);
    
    if (result && result.ok) {
      console.log(`‚úÖ Admin notified about payment, message_id: ${result.result.message_id}`);
      return { success: true, messageId: result.result.message_id };
    }
    
    console.log('‚ùå Failed to notify admin about payment');
    return { success: false };
  }

  /**
   * 3. –£–≤–µ–¥–æ–º–∏—Ç—å –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞ –æ–± –æ–ø–ª–∞—Ç–µ
   */
  static async notifySupplierPaymentConfirmed(purchase: Purchase): Promise<boolean> {
    console.log(`üí∏ Notifying supplier about payment confirmation for purchase #${purchase.id}`);

    const message: TelegramMessage = {
      chat_id: this.SUPPLIER_ID,
      text: `üí∏ <b>–û–ø–ª–∞—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞!</b>

${this.formatPurchase({ ...purchase, status: 'paid' })}

<i>–ó–∞–∫–∞–∑ –æ–ø–ª–∞—á–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–≥–æ—Ç–æ–≤—å—Ç–µ —Ç–æ–≤–∞—Ä—ã –∏ –ø–µ—Ä–µ–¥–∞–π—Ç–µ –≤ –∫–∞—Ä–≥–æ.</i>`,
      parse_mode: 'HTML',
      reply_markup: {
        inline_keyboard: [
          [
            {
              text: 'üì¶ –ü–µ—Ä–µ–¥–∞–Ω–æ –≤ –∫–∞—Ä–≥–æ',
              callback_data: `purchase_shipped_${purchase.id}`
            }
          ]
        ]
      }
    };

    const result = await this.sendMessage(message);
    return result && result.ok;
  }

  /**
   * 4. –£–≤–µ–¥–æ–º–∏—Ç—å –≤ –≥—Ä—É–ø–ø—É –æ –ø–µ—Ä–µ–¥–∞—á–µ –≤ –∫–∞—Ä–≥–æ
   */
  static async notifyGroupShipped(purchase: Purchase): Promise<boolean> {
    console.log(`üöö Notifying group about shipment for purchase #${purchase.id}`);

    const message: TelegramMessage = {
      chat_id: this.GROUP_CHAT_ID,
      text: `üöö <b>–ó–∞–∫—É–ø–∫–∞ –ø–µ—Ä–µ–¥–∞–Ω–∞ –≤ –∫–∞—Ä–≥–æ</b>

${this.formatPurchase({ ...purchase, status: 'shipped' })}

<i>–¢–æ–≤–∞—Ä—ã –ø–µ—Ä–µ–¥–∞–Ω—ã –≤ –∫–∞—Ä–≥–æ –∏ –≥–æ—Ç–æ–≤—ã –∫ –æ—Ç–ø—Ä–∞–≤–∫–µ.</i>`,
      parse_mode: 'HTML'
    };

    const result = await this.sendMessage(message);
    return result && result.ok;
  }

  /**
   * 5. –£–≤–µ–¥–æ–º–∏—Ç—å –≥—Ä—É–ø–ø—É –æ –Ω–æ–≤–æ–π –∑–∞–∫—É–ø–∫–µ
   */
  static async notifyGroupNewPurchase(purchase: Purchase): Promise<{ success: boolean; messageId?: number }> {
    console.log(`üì¢ Notifying group about new purchase #${purchase.id}`);

    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –æ–±—â—É—é —Å—É–º–º—É –≤ –ª–∏—Ä–∞—Ö
    const totalPrimeCostTry = purchase.items.reduce((sum, item) => sum + (item.costPrice * item.quantity), 0);

    // –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ —Ç–æ–≤–∞—Ä–æ–≤ —Å —Å–µ–±–µ—Å—Ç–æ–∏–º–æ—Å—Ç—å—é –≤ –ª–∏—Ä–∞—Ö
    const itemsText = purchase.items
      .map(item => {
        const itemTotal = item.costPrice * item.quantity;
        return `‚Ä¢ <b>${item.productName}</b>\n  ${item.quantity} —à—Ç. √ó ‚Ç∫${item.costPrice.toFixed(2)} = <b>‚Ç∫${itemTotal.toFixed(2)}</b>`;
      })
      .join('\n\n');

    const urgentTag = purchase.isUrgent ? 'üî¥ <b>–°–†–û–ß–ù–ê–Ø –ó–ê–ö–£–ü–ö–ê!</b>\n\n' : '';

    const message: TelegramMessage = {
      chat_id: this.GROUP_CHAT_ID,
      text: `üìã <b>–ù–æ–≤–∞—è –∑–∞–∫—É–ø–∫–∞ #${purchase.id}</b>

<b>–¢–æ–≤–∞—Ä—ã –∏ —Å–µ–±–µ—Å—Ç–æ–∏–º–æ—Å—Ç—å:</b>
${itemsText}

üí∞ <b>–û–±—â–∞—è —Å–µ–±–µ—Å—Ç–æ–∏–º–æ—Å—Ç—å: ‚Ç∫${totalPrimeCostTry.toFixed(2)}</b>

üìÖ <b>–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è:</b> ${new Date(purchase.createdAt).toLocaleString('ru-RU', { 
        timeZone: 'Europe/Moscow',
        day: '2-digit',
        month: '2-digit', 
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      })}${purchase.supplierName ? `\nüè™ <b>–ü–æ—Å—Ç–∞–≤—â–∏–∫:</b> ${purchase.supplierName}` : ''}${purchase.notes ? `\nüìù <b>–ü—Ä–∏–º–µ—á–∞–Ω–∏—è:</b> ${purchase.notes}` : ''}

<i>–ó–∞–∫—É–ø–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –ø–æ—Å—Ç–∞–≤—â–∏–∫—É –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏.</i>`,
      parse_mode: 'HTML',
      reply_markup: {
        inline_keyboard: [
          [
            {
              text: 'üí∞ –ù—É–∂–Ω–æ –æ–ø–ª–∞—Ç–∏—Ç—å',
              callback_data: `purchase_payment_needed_${purchase.id}`
            }
          ]
        ]
      }
    };

    const result = await this.sendMessage(message);
    
    if (result && result.ok) {
      console.log(`‚úÖ Group notified about new purchase, message_id: ${result.result.message_id}`);
      return { success: true, messageId: result.result.message_id };
    }
    
    console.log('‚ùå Failed to notify group about new purchase');
    return { success: false };
  }

  /**
   * –û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∑–∞–∫—É–ø–∫–∏ —É –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞
   */
  static async updateSupplierPurchaseStatus(
    chatId: number | string, 
    messageId: number, 
    purchase: Purchase
  ): Promise<boolean> {
    console.log(`üìù Updating supplier message for purchase #${purchase.id}`);

    const webAppUrl = `${process.env.NEXTAUTH_URL || 'http://localhost:3000'}/telegram-webapp/purchase-editor.html?purchaseId=${purchase.id}`;
    
    let replyMarkup;
    
    if (purchase.status === 'sent_to_supplier' || purchase.status === 'supplier_editing') {
      replyMarkup = {
        inline_keyboard: [
        [
          {
              text: 'üìù –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –∑–∞–∫—É–ø–∫—É',
            web_app: {
              url: webAppUrl
            }
          }
          ],
          [
            {
              text: 'üí∞ –ì–æ—Ç–æ–≤–æ –∫ –æ–ø–ª–∞—Ç–µ',
              callback_data: `purchase_ready_${purchase.id}`
            }
        ]
        ]
      };
    } else if (purchase.status === 'paid') {
      replyMarkup = {
        inline_keyboard: [
        [
          {
              text: 'üì¶ –ü–µ—Ä–µ–¥–∞–Ω–æ –≤ –∫–∞—Ä–≥–æ',
              callback_data: `purchase_shipped_${purchase.id}`
          }
        ]
        ]
      };
    }

    const text = this.formatPurchase(purchase);
    const result = await this.editMessage(chatId, messageId, text, replyMarkup);
    return result && result.ok;
  }

  /**
   * –û–±—Ä–∞–±–æ—Ç–∞—Ç—å callback –æ—Ç –∫–Ω–æ–ø–æ–∫
   */
  static async handleCallback(callbackQuery: any): Promise<boolean> {
    const { id: callbackQueryId, data: callbackData, from, message } = callbackQuery;
    
    console.log(`üîÑ Handling callback: ${callbackData} from user ${from.id}`);

    if (!callbackData) {
      await this.answerCallbackQuery(callbackQueryId, '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞');
      return false;
    }

    try {
      // –ü–∞—Ä—Å–∏–º callback data
      const [action, ...params] = callbackData.split('_');
      
      if (action === 'purchase') {
        const [subAction, ...rest] = params;
        let purchaseIdNum: number;

        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Ä–∞–∑–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã callback data
        if (subAction === 'payment' && rest[0] === 'needed') {
          // –§–æ—Ä–º–∞—Ç: purchase_payment_needed_123
          purchaseIdNum = parseInt(rest[1]);
        } else {
          // –§–æ—Ä–º–∞—Ç: purchase_ready_123, purchase_paid_123, etc.
          purchaseIdNum = parseInt(rest[0]);
        }

        if (isNaN(purchaseIdNum)) {
          await this.answerCallbackQuery(callbackQueryId, '–ù–µ–≤–µ—Ä–Ω—ã–π ID –∑–∞–∫—É–ø–∫–∏');
          return false;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        const userId = from.id.toString();
        
        switch (subAction) {
          case 'payment':
            // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º "payment_needed" - —Ç–æ–ª—å–∫–æ –ø–æ—Å—Ç–∞–≤—â–∏–∫ –º–æ–∂–µ—Ç –æ—Ç–º–µ—Ç–∏—Ç—å —á—Ç–æ –Ω—É–∂–Ω–∞ –æ–ø–ª–∞—Ç–∞
            if (rest[0] === 'needed') {
              if (userId !== this.SUPPLIER_ID) {
                await this.answerCallbackQuery(callbackQueryId, '–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è');
                return false;
              }
              
              // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–∞–∂–∞—Ç–∏–π
              const clickResult = await this.handlePaymentButtonClick(purchaseIdNum, message);
              
              if (clickResult.limitReached) {
                await this.answerCallbackQuery(callbackQueryId, '–ö–Ω–æ–ø–∫–∞ –±–æ–ª—å—à–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ (–º–∞–∫—Å–∏–º—É–º 3 –Ω–∞–∂–∞—Ç–∏—è)');
                return false;
              }
              
              await this.answerCallbackQuery(callbackQueryId, `–£–≤–µ–¥–æ–º–ª—è–µ–º –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ (${clickResult.clickCount}/3)...`);
              console.log(`üí∞ Purchase #${purchaseIdNum} payment request #${clickResult.clickCount} by supplier`);
              
              // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ –≥—Ä—É–ø–ø—É
              await this.sendPaymentNotificationToGroup(purchaseIdNum, clickResult.clickCount);
              
              // –ï—Å–ª–∏ –¥–æ—Å—Ç–∏–≥–ª–∏ –ª–∏–º–∏—Ç–∞ –≤ 3 –Ω–∞–∂–∞—Ç–∏—è, —É–±–∏—Ä–∞–µ–º –∫–Ω–æ–ø–∫—É
              if (clickResult.clickCount >= 3) {
                await this.removePaymentButton(message.chat.id, message.message_id, purchaseIdNum);
              }
            }
            break;

          case 'ready':
            // –¢–æ–ª—å–∫–æ –ø–æ—Å—Ç–∞–≤—â–∏–∫ –º–æ–∂–µ—Ç –æ—Ç–º–µ—Ç–∏—Ç—å –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å –∫ –æ–ø–ª–∞—Ç–µ
            if (userId !== this.SUPPLIER_ID) {
              await this.answerCallbackQuery(callbackQueryId, '–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è');
              return false;
            }
            
            await this.answerCallbackQuery(callbackQueryId, '–£–≤–µ–¥–æ–º–ª—è–µ–º –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –æ–± –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –∫ –æ–ø–ª–∞—Ç–µ...');

            // –ó–¥–µ—Å—å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤—ã–∑–æ–≤ API –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∞–¥–º–∏–Ω–∞
            // –ü–æ–∫–∞ —á—Ç–æ –ø—Ä–æ—Å—Ç–æ –ª–æ–≥–∏—Ä—É–µ–º
            console.log(`‚úÖ Purchase #${purchaseIdNum} marked as ready for payment by supplier`);
            
            // –í—ã–∑—ã–≤–∞–µ–º API –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞
            await this.callPurchaseStatusAPI(purchaseIdNum, 'awaiting_payment');
            break;

          case 'paid':
            // –¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –º–æ–∂–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –æ–ø–ª–∞—Ç—É
            if (userId !== this.ADMIN_ID) {
              await this.answerCallbackQuery(callbackQueryId, '–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è');
              return false;
            }
            
            await this.answerCallbackQuery(callbackQueryId, '–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ–º –æ–ø–ª–∞—Ç—É...');
            console.log(`üí∞ Purchase #${purchaseIdNum} marked as paid by admin`);
            
            await this.callPurchaseStatusAPI(purchaseIdNum, 'paid');
            break;

          case 'shipped':
            // –¢–æ–ª—å–∫–æ –ø–æ—Å—Ç–∞–≤—â–∏–∫ –º–æ–∂–µ—Ç –æ—Ç–º–µ—Ç–∏—Ç—å –ø–µ—Ä–µ–¥–∞—á—É –≤ –∫–∞—Ä–≥–æ
            if (userId !== this.SUPPLIER_ID) {
              await this.answerCallbackQuery(callbackQueryId, '–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è');
              return false;
            }
            
            await this.answerCallbackQuery(callbackQueryId, '–û—Ç–º–µ—á–∞–µ–º –ø–µ—Ä–µ–¥–∞—á—É –≤ –∫–∞—Ä–≥–æ...');
            console.log(`üì¶ Purchase #${purchaseIdNum} marked as shipped by supplier`);
            
            await this.callPurchaseStatusAPI(purchaseIdNum, 'shipped');
            break;

          case 'cancel':
            // –¢–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –º–æ–∂–µ—Ç –æ—Ç–º–µ–Ω–∏—Ç—å
            if (userId !== this.ADMIN_ID) {
              await this.answerCallbackQuery(callbackQueryId, '–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–π—Å—Ç–≤–∏—è');
              return false;
            }
            
            await this.answerCallbackQuery(callbackQueryId, '–û—Ç–º–µ–Ω—è–µ–º –∑–∞–∫—É–ø–∫—É...');
            console.log(`‚ùå Purchase #${purchaseIdNum} cancelled by admin`);
            
            await this.callPurchaseStatusAPI(purchaseIdNum, 'cancelled');
            break;

          default:
            await this.answerCallbackQuery(callbackQueryId, '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –¥–µ–π—Å—Ç–≤–∏–µ');
            return false;
        }
          
          return true;
        }

      await this.answerCallbackQuery(callbackQueryId, '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞');
      return false;

    } catch (error) {
      console.error('‚ùå Error handling callback:', error);
      await this.answerCallbackQuery(callbackQueryId, '–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –∫–æ–º–∞–Ω–¥—ã');
      return false;
    }
  }

  /**
   * –û–±—Ä–∞–±–æ—Ç–∞—Ç—å –Ω–∞–∂–∞—Ç–∏–µ –∫–Ω–æ–ø–∫–∏ "–ù—É–∂–Ω–æ –æ–ø–ª–∞—Ç–∏—Ç—å"
   */
  private static async handlePaymentButtonClick(purchaseId: number, message: any): Promise<{ clickCount: number; limitReached: boolean }> {
    try {
      const baseUrl = process.env.NEXTAUTH_URL || 'http://localhost:3000';
      const response = await fetch(`${baseUrl}/api/purchases/${purchaseId}/payment-button-click`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      if (!response.ok) {
        throw new Error(`API call failed: ${response.status} ${response.statusText}`);
      }

      const result = await response.json();
      return result;
    } catch (error) {
      console.error(`‚ùå Failed to handle payment button click for purchase #${purchaseId}:`, error);
      return { clickCount: 1, limitReached: false };
    }
  }

  /**
   * –û—Ç–ø—Ä–∞–≤–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ –≥—Ä—É–ø–ø—É –æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –æ–ø–ª–∞—Ç—ã
   */
  private static async sendPaymentNotificationToGroup(purchaseId: number, clickCount: number): Promise<void> {
    const message: TelegramMessage = {
      chat_id: this.GROUP_CHAT_ID,
      text: `üí∞ <b>–¢—Ä–µ–±—É–µ—Ç—Å—è –æ–ø–ª–∞—Ç–∞ –∑–∞–∫—É–ø–∫–∏</b>

@osama_digital –ù—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å –æ–ø–ª–∞—Ç—É –∑–∞–∫—É–ø–∫–∏ #${purchaseId}

<i>–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ ${clickCount}/3</i>`,
      parse_mode: 'HTML'
    };

    const result = await this.sendMessage(message);
    
    if (result && result.ok) {
      console.log(`‚úÖ Payment notification sent to group for purchase #${purchaseId}, attempt ${clickCount}`);
    } else {
      console.log(`‚ùå Failed to send payment notification to group for purchase #${purchaseId}`);
    }
  }

  /**
   * –£–±—Ä–∞—Ç—å –∫–Ω–æ–ø–∫—É "–ù—É–∂–Ω–æ –æ–ø–ª–∞—Ç–∏—Ç—å" –ø–æ—Å–ª–µ 3 –Ω–∞–∂–∞—Ç–∏–π
   */
  private static async removePaymentButton(chatId: number | string, messageId: number, purchaseId: number): Promise<void> {
    try {
      // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ –∑–∞–∫—É–ø–∫–µ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è
      const baseUrl = process.env.NEXTAUTH_URL || 'http://localhost:3000';
      const response = await fetch(`${baseUrl}/api/purchases/${purchaseId}`);
      
      if (!response.ok) {
        throw new Error(`Failed to fetch purchase data: ${response.status}`);
      }
      
      const purchase = await response.json();
      
      // –ü–µ—Ä–µ—Å–æ–∑–¥–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –±–µ–∑ –∫–Ω–æ–ø–∫–∏
      const totalPrimeCostTry = purchase.items.reduce((sum: number, item: any) => sum + (item.unitcosttry * item.quantity), 0);

      const itemsText = purchase.items
        .map((item: any) => {
          const itemTotal = item.unitcosttry * item.quantity;
          return `‚Ä¢ <b>${item.productname}</b>\n  ${item.quantity} —à—Ç. √ó ‚Ç∫${item.unitcosttry.toFixed(2)} = <b>‚Ç∫${itemTotal.toFixed(2)}</b>`;
        })
        .join('\n\n');

      const newText = `üìã <b>–ù–æ–≤–∞—è –∑–∞–∫—É–ø–∫–∞ #${purchase.id}</b>

<b>–¢–æ–≤–∞—Ä—ã –∏ —Å–µ–±–µ—Å—Ç–æ–∏–º–æ—Å—Ç—å:</b>
${itemsText}

üí∞ <b>–û–±—â–∞—è —Å–µ–±–µ—Å—Ç–æ–∏–º–æ—Å—Ç—å: ‚Ç∫${totalPrimeCostTry.toFixed(2)}</b>

üìÖ <b>–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è:</b> ${new Date(purchase.createdat).toLocaleString('ru-RU', { 
        timeZone: 'Europe/Moscow',
        day: '2-digit',
        month: '2-digit', 
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      })}${purchase.suppliername ? `\nüè™ <b>–ü–æ—Å—Ç–∞–≤—â–∏–∫:</b> ${purchase.suppliername}` : ''}${purchase.notes ? `\nüìù <b>–ü—Ä–∏–º–µ—á–∞–Ω–∏—è:</b> ${purchase.notes}` : ''}

<i>–ó–∞–∫—É–ø–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ –ø–æ—Å—Ç–∞–≤—â–∏–∫—É –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏.</i>

‚ö†Ô∏è <i>–ö–Ω–æ–ø–∫–∞ –æ–ø–ª–∞—Ç—ã –±–æ–ª—å—à–µ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ (–¥–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç 3 –Ω–∞–∂–∞—Ç–∏—è)</i>`;

      const result = await this.editMessage(chatId, messageId, newText);
      
      if (result && result.ok) {
        console.log(`‚úÖ Payment button removed for purchase #${purchaseId}`);
      } else {
        console.log(`‚ùå Failed to remove payment button for purchase #${purchaseId}`);
      }
    } catch (error) {
      console.error(`‚ùå Error removing payment button for purchase #${purchaseId}:`, error);
    }
  }

  /**
   * –í—ã–∑–≤–∞—Ç—å API –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–∫—É–ø–∫–∏
   */
  private static async callPurchaseStatusAPI(purchaseId: number, newStatus: string): Promise<void> {
    try {
      const baseUrl = process.env.NEXTAUTH_URL || 'http://localhost:3000';
      const response = await fetch(`${baseUrl}/api/purchases/${purchaseId}/status`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
          },
        body: JSON.stringify({ status: newStatus }),
        });

      if (!response.ok) {
        throw new Error(`API call failed: ${response.status} ${response.statusText}`);
      }

      console.log(`‚úÖ Purchase #${purchaseId} status updated to ${newStatus}`);
    } catch (error) {
      console.error(`‚ùå Failed to update purchase #${purchaseId} status:`, error);
    }
  }

  /**
   * –û—Ç–≤–µ—Ç–∏—Ç—å –Ω–∞ callback query
   */
  private static async answerCallbackQuery(callbackQueryId: string, text: string): Promise<void> {
    try {
      await fetch(`${this.API_URL}/answerCallbackQuery`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          callback_query_id: callbackQueryId,
          text,
          show_alert: false,
        }),
      });
    } catch (error) {
      console.error('‚ùå Error answering callback query:', error);
    }
  }

  /**
   * –ü–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –±–æ—Ç–µ (–¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è)
   */
  static async getBotInfo(): Promise<any> {
    if (!this.BOT_TOKEN) {
      return { error: 'Bot token not configured' };
    }

    try {
      const response = await fetch(`${this.API_URL}/getMe`);
      const result = await response.json();
      return result;
    } catch (error: any) {
      console.error('‚ùå Error getting bot info:', error);
      return { error: error.message };
    }
  }
} 